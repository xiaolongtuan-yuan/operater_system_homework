# 第一章 导论
### 1.1操作系统的三个主要目的是什么?
答:
为计算机用户提供一个方便、有效地在计算机上执行程序的环境。
根据需要分配计算机的不同资源来解决给定的问题。分配过程应尽可能公平和有效。
作为一个控制程序，它有两个主要功能:(1)监督用户程序的执行，以防止错误和不适当的使用计算机(2)管理操作和控制的I/O设备。
### 1.3在为实时环境编写操作系统时，程序员必须克服的主要困难是什么?
答:主要的困难是保持操作系统在实时系统的固定时间限制内。如果系统没有在一定时间内完成某个任务，可能会导致正在运行的整个系统崩溃。因此，在为实时系统编写操作系统时，编写者必须确保他的调度方案不允许响应时间超过时间限制。

### 1.4牢记操作系统的各种定义，考虑操作系统是否应包括Web等应用程序浏览器和邮件程序。 争论它应该和它应该不是，并支持你的答案。
答:支持操作系统包括流行的应用程序：如果应用程序嵌入到操作系统,它可能更好地利用在内核中的特性,比在内核以外的应用程序具有更好的性能优势。反对在操作系统中嵌入应用程序的争论通常占主导地位:(1)应用程序是应用程序——而不是操作系统的一部分，(2)在内核中运行的任何性能好处都会被安全漏洞抵消，(3)它会导致操作系统膨胀。
### 1.6下列哪些指令需要拥有特权（包含在内核中执行）
a. Set value of timer.
b. Read the clock.
c. Clear memory.
d. Issue a trap instruction.
e. Turn off interrupts.
f. Modify entries in device-status table.
g. Switch from user to kernel mode.
h. Access I/O device.

答：Set value of timer, clear memory, turn off interrupts, modify entries in device-status table, access I/O device.其他指令可以在用户模块中执行

### 1.9可以使用计时器来计算当前时间。提供一个简短的描述，说明如何实现这一点。
答：一个程序可以使用下面的方法来计算使用定时器中断的当前时间。该程序可以为未来的某个时间设置一个计时器，然后进入睡眠状态。当它被中断唤醒时，它可以更新它的本地状态，用来跟踪到目前为止它收到的中断的数量。然后，它可以重复这个过程，不断设置计时器中断，并在中断实际引发时更新其本地状态。
### 1.12在多道程序和分时环境中，多个用户同时共享系统。这种情况会导致各种安全问题。
a：这两个问题是什么?
b：我们能否确保分时机器和专用机器一样的安全性？解释你的答案。
答:a.窃取或复制自己的程序或数据;在没有合理核算的情况下使用系统资源(CPU、内存、磁盘空间、外设)。
b.可能不会，因为人类设计的任何保护方案都不可避免地会被人打破，而且方案越复杂，就越难以对其正确实施有信心。
### 1.14在什么情况下，用户最好使用分时系统而不是 PC 或单用户工作站？
答：当其他用户很少，任务很大，而且硬件速度很快时，分时是合理的。系统的全部功能可以用来解决用户的问题。这个问题可以比在个人电脑上更快地解决。另一种情况是，许多其他用户同时需要资源。当工作足够小，可以合理地在上面执行，并且性能足够执行程序，使用户满意时，个人计算机是最好的。
### 1.19中断的目的是什么？ 陷阱和中断之间有什么区别？ 陷阱可以由用户程序有意生成吗？ 如果是这样，出于什么目的？
答:中断是系统中由硬件生成的流变更。一个中断处理器被调用来处理中断的原因；然后将控制返回给中断的上下文和指令。陷阱是一种软件生成的中断。中断可以用来发出I/O完成的信号，以避免设备轮询的需要。陷阱可以用来调用操作系统例程或捕获算术错误。
### 1.21有些计算机系统在硬件上不提供特殊的操作模式。有可能为这些计算机系统构建一个安全的操作系统吗?给出它是和它是不可能的论据。
答:这类机器的操作系统需要始终处于控制状态(或监控模式)。这可以通过两种方法来实现:
a：所有用户程序的软件解释(例如一些BASIC、Java和LISP系统)。软件解释器可以在软件中提供硬件不能提供的东西。
b：所有的程序都要用高级语言编写，这样所有的目标代码都是由编译器生成的。编译器将生成(内联或通过函数调用)保护检查，以确定硬件是否缺失。
# 第二章 操作系统结构
### 2.1系统调用（system call）的目的是什么？
答：系统调用允许用户级进程请求操作系统的服务
### 2.5命令解释程序（command interpreter）的目的是什么?为什么它通常与内核分离?
答：它从用户输入或命令文件中读取命令并执行它们，通常是将它们转换为一个或多个系统调用。
命令解释程序通常不是内核的一部分，因为命令解释程序有很多变化，有的系统甚至有多个命令解释程序。
### 2.8系统设计的分层方法（layered approach）的主要优势是什么?使用分层方法的缺点是什么?
答：分层法作为系统模块化的一种方法，其主要优点在于简化了构造和调试。
其主要难点在于合理定义各层，由于每层只能利用更底层的功能，有必要仔细规划。并且分层法与其他方法相比效率更差。
### 2.12操作系统提供的服务和功能可以分为两大类。简要描述这两类并讨论它们的区别。
答：操作系统提供的一类服务是在系统中同时运行的不同进程之间实施保护。 进程只允许访问与其地址空间相关联的那些内存位置。 此外，不允许进程损坏与其他用户关联的文件。 进程也不允许在没有操作系统干预的情况下直接访问设备。 操作系统提供的第二类服务是提供底层硬件不直接支持的新功能。 虚拟内存和文件系统就是操作系统提供的两个这样的新服务示例。
### 2.16使用相同的系统调用接口来操作文件和设备有什么优点和缺点？
答：可以像访问文件系统中的文件一样访问每个设备。 由于大多数内核通过这个文件接口处理设备，通过实现特定于硬件的代码来支持这个抽象文件接口来添加新的设备驱动程序相对容易。 因此，这有利于开发用户程序代码（可以编写为以相同方式访问设备和文件）和设备驱动程序代码（可以编写为支持定义良好的 API）。 使用相同接口的缺点是可能难以在文件访问 API 的上下文中捕获某些设备的功能，从而导致功能损失或性能损失。 其中一些问题可以通过使用 ioctl 操作来克服，该操作为进程调用设备上的操作提供了一个通用接口。
### 2.17用户是否可以使用操作系统提供的系统调用接口来开发一个新的命令解释程序?
答：用户应该能够使用操作系统提供的系统调用接口开发新的命令解释程序。 命令解释程序允许用户创建和管理进程并确定它们通信的方式（例如通过管道和文件）。 由于所有这些功能都可以由用户级程序使用系统调用来访问，因此用户应该可以开发一个新的命令行解释程序。
### 2.21系统设计的微内核方法的主要优势是什么?在微内核体系结构中，用户程序和系统服务如何交互?使用微内核方法的缺点是什么?
答：好处通常包括以下（a）添加新服务不需要修改内核，（b）它更安全，因为在用户模式下比在内核模式下完成更多操作，（c）更简单的内核设计和功能通常 导致更可靠的操作系统。 
用户程序和系统服务通过使用进程间通信机制（例如消息传递）在微内核体系结构中进行交互。 这些消息由操作系统传送。 
微内核架构的主要缺点是与进程间通信相关的开销以及频繁使用操作系统的消息传递功能以使用户进程和系统服务能够相互交互。
# 第三章 进程
### 3.1在图3.30所示的程序，解释line A上的输出。![在这里插入图片描述](https://img-blog.csdnimg.cn/a525f95a450e4719be981e5fb41c945e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6b6Z5Yek5Zui6Iy2,size_20,color_FFFFFF,t_70,g_se,x_16)

答:使用fork()创建子进程后，子进程拥有自己的内存地址，在子进程中返回值为0，即pid=0，修改value为15，因为子进程中value和父进程的value内存地址不一样，所以父进程的value任为5；而在父进程中，fork()返回的是子进程的进程id>0，直接打印PARENT: value = 5
### 3.2包括初始父进程，图3.31中显示的程序创建了多少进程?
![在这里插入图片描述](https://img-blog.csdnimg.cn/8b38e6bbfbac4d4f90afdbeffc65e00e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6b6Z5Yek5Zui6Iy2,size_15,color_FFFFFF,t_70,g_se,x_16)

答:总共创建了8个进程。
### 3.5当一个进程使用fork()操作创建一个新进程时，父进程和子进程共享下列哪个状态? a栈    b堆    c共享内存段
答:只有共享内存段在父进程和新分叉的子进程之间共享。为新创建的进程复制堆栈。

### 3.8描述短期调度程序、中期调度程序和长期调度程序之间的区别。
答:短期调度程序(CPU调度程序)——从准备执行的进程中选择进程，并分配CPU。
中期调度程序，将进程从内存（或从CPU竞争）中移出，从而降低多道程序程度。之后进程看重新被调入内存，并从中断出继续执行。实现一种交换方案。
长期调度程序(作业调度程序)——从进程缓冲池中选择进程加到内存中，以便执行。
他们主要的区别在于执行的频率。短期调度程序必须经常为CPU选择新的进程。长期调度程序并不频繁，因为长期调度程序控制多道程序进程，必须保证多道程序进程的稳定，为此创建创建程序的平均速度必须等于进程离系统的平均速度。所以只有在进程离开系统时才会需要长期调用程序的调度。
### 3.9描述内核在进程之间进行上下文切换时所采取的动作。
答:内核会将旧进程状态保存在其PCB中，然后加载经调度后的要执行的新进程的上下文。上下文切换的工作量与硬件支持密切相关，例如有的处理器提供了多个寄存器组，上下文切换只需简单改变寄存器组的指针，但如果活动进程数超过寄存器组数，系统就需要在寄存器和内存之间进行数据复制。
### 3.12包括初始父进程，图3.32中显示的程序创建了多少个进程?
![在这里插入图片描述](https://img-blog.csdnimg.cn/4e5844f6fceb4507a84cf700719dc87d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6b6Z5Yek5Zui6Iy2,size_15,color_FFFFFF,t_70,g_se,x_16)
答：共创建16个进程。
### 3.13解释在什么情况下会到达图3.33中标记为printf(“line J”)的代码行。
![在这里插入图片描述](https://img-blog.csdnimg.cn/ffe12be587dc47868edb218dc6fddfcc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6b6Z5Yek5Zui6Iy2,size_20,color_FFFFFF,t_70,g_se,x_16)
答：当子进程创建成功后，调用execlp()加载/bin/ls程序的代码和静态数据，若调用成功，则永远不会执行printf(“line J”)；若调用失败（如不存在/bin/ls这样的可执行程序），才会执行printf(“line J”)
### 3.14使用图3.34中的程序，确定A、B、C和D行的pid值(假设父进程和子进程的实际pid分别为2600和2603)。![在这里插入图片描述](https://img-blog.csdnimg.cn/9ef04445805241dbb069f3eab6460eff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6b6Z5Yek5Zui6Iy2,size_20,color_FFFFFF,t_70,g_se,x_16)
答：
A: pid=0
B: pid1 = 2603
C: pid = 2603
D: pid = 2600
## 第四章 线程
### 4.1提供三个编程示例，在这些示例中，多线程比单线程解决方案提供更好的性能。
答:1、一个Web服务器，需要接受有关网页、图像、声音的请求，同时处理上千个用户的访问请求。
2、一个并行的应用程序，如矩阵乘法，其中矩阵的不同部分可以并行处理。
3、一种交互式的字处理器，一个线程用于显示图形，一个线程用于响应用户键盘输入，还有一个线程用于在后台进行拼写和语法检查。
### 4.2用户线程和内核线程之间的两个区别是什么?在什么情况下，一种比另一种好?
答:1、用户线程位于内核之上，他的管理无需内核支持，而内核线程由操作系统来直接支持与管理。
2、在使用一对一模型或多对多模型的系统上，用户线程由线程库调度，而内核调度内核线程。
内核线程不需要与一个进程相关联，而每个用户线程都属于一个进程。内核线程通常比用户线程的维护成本更高，因为它们必须用内核数据结构表示。
### 4.3描述内核在内核级线程之间进行上下文切换时所采取的动作。
答:内核线程之间的上下文切换通常需要保存被切换出去的线程的CPU寄存器的值，并恢复被调度的新线程的CPU寄存器。
### 4.4创建线程时使用哪些资源?它们与创建进程时使用的方法有何不同?
答:因为线程比进程小，所以创建线程通常比创建进程使用更少的资源。创建一个进程需要分配一个进程控制块(PCB)，这是一个相当大的数据结构。PCB包括内存映射、打开的文件列表和环境变量。分配和管理内存映射通常是最耗时的活动。创建用户或内核线程都需要分配一个小数据结构来保存寄存器集、堆栈和优先级。
### 4.6提供两个编程示例，在这些示例中，多线程并不比单线程解决方案提供更好的性能
答:顺序程序不适合多线程编程。例子：
1、一个计算个人纳税申报单的程序。
2、“shell”程序，如C-shell或Korn shell。这样的程序必须密切监视自己的工作空间，如打开的文件、环境变量和当前工作目录。
### 4.7在什么情况下，使用多个内核线程的多线程解决方案比单处理器系统中的单线程解决方案提供更好的性能?
答:当内核线程发生页面错误时，可以切换到另一个内核线程，以一种有用的方式使用交错时间。另一方面，当发生页面错误时，单线程进程将无法执行有用的工作。因此，在程序可能出现频繁的页面错误或必须等待其他系统事件的情况下，多线程解决方案甚至在单处理器系统上也能执行得更好。
### 4.8在多线程进程中，程序状态的下列哪些组件是跨线程共享的?a寄存器值 b堆内存 c全局变量 d栈内存
答:多线程进程的线程共享堆内存和全局变量。每个线程都有其独立的寄存器值集和独立的栈。
### 4.9使用多个用户级线程的多线程解决方案能否在多处理器系统上比在单处理器系统上获得更好的性能?
答:由多个用户级线程组成的多线程系统不能在多处理器系统中同时使用不同的处理器。操作系统只看到一个进程，不会将该进程的不同线程调度到不同的处理器上。因此，在多处理器系统上执行多个用户级线程不会带来性能上的好处。
### 4.11是否可能有并发性但没有并行性?解释一下。
答：可以，系统的并行性（parallelism）是指在同一时间执行多个任务，并发性（concurrency）是指系统能够支持多个任务，允许所有任务都能取得进展。因此没有并行，通过系统的调度也可以实现并发。
### 4.15考虑下面的代码段![在这里插入图片描述](https://img-blog.csdnimg.cn/ecc4b023afdb4e3f9c4911831db8421f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6b6Z5Yek5Zui6Iy2,size_20,color_FFFFFF,t_70,g_se,x_16)（1）创建了多少个独特的进程?（2）创建了多少个独特的线程?
答：（1）6个进程
（2）8个线程

# 第五章 同步（Synchronization）
### 5.3 “忙等待（busy waiting）”是什么意思?在操作系统中还有什么其他类型的等待?能否完全避免繁忙的等待?解释你的答案。
答：忙等待（也叫自旋锁）意味着一个进程为了等待某个条件得到满足，连续循环的调用acquire()，不放弃处理器。忙等待是可以避免的，进程可以通过放弃处理器进入沉睡状态（阻塞）来等待，等待在未来的某个适当时间被唤醒。但将进程置于睡眠状态并且在达到适当的程序状态时将其唤醒，会导致额外的开销。
### 5.5 请说明，如果wait()和signal()信号量操作不是原子执行的，则可能会违反互斥原则。
答：wait()操作以原子的方式递减与信号量相关的值。如果一个信号量的值为1时，在该信号量上执行了两个等待操作，如果这两个操作不是原子执行的，那么这两个操作可能会继续减小信号量的值，从而违反互斥。
### 5.6 说明如何使用二进制信号量实现n个进程之间的互斥。
答：n个进程共享一个初始化为1的信号量mutex。每个过程Pi组织如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/51cf86a692044b8e92768a5af1a954ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6b6Z5Yek5Zui6Iy2,size_13,color_FFFFFF,t_70,g_se,x_16)
### 5.10 请解释：为什么在单处理器系统上通过禁止中断来实现同步原语的方法不适用于用户级程序
答：如果用户级程序具有禁用中断的能力，那么它可以禁用计时器中断并防止发生上下文切换，从而不让其他进程执行，达到独占处理器的目的。
### 5.11 请解释为什么中断不适合在多处理器系统来实现同步原语
答：如果多个进程运行在不同的CPU上，每个进程都试图进入一个临界区，即使禁止中断，其他进程依旧能够在其他处理器上进入临界区。
### 5.13 请描述可能存在竞争条件的两个内核数据结构。一定要有如何可能发生竞争条件的描述。

### 5.23 展示如何在多处理器环境中使用TestAndSet()指令实现wait()和signal()信号量操作。方案应该表现最小的忙等待。
答：伪代码如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/d2d3ffc2e3884d228457ce5cd9c8997b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6b6Z5Yek5Zui6Iy2,size_20,color_FFFFFF,t_70,g_se,x_16)
### 5.25 请解释：监控器和信号量是等价的，因为它们可以用来实现对相同类型的同步问题的解决方案。
答：可以使用下面的监视代码实现信号量：
![在这里插入图片描述](https://img-blog.csdnimg.cn/655f36e2fbb34c458aaddc6589c6b7b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6b6Z5Yek5Zui6Iy2,size_12,color_FFFFFF,t_70,g_se,x_16)
监视器可以通过以下方式使用信号量来实现。每个条件变量都由一个等待条件的线程队列表示。每个线程都有一个与其队列条目相关联的信号量。当线程执行等待操作时，它会创建一个新的信号量(初始化为0)，将该信号量添加到与条件变量相关的队列中，并对新创建的信号量执行阻塞信号量递减操作。当一个线程在一个条件变量上执行一个信号时，队列中的第一个进程将通过对相应的信号量执行递增操作而被唤醒。
### 5.32 一个文件在不同的进程之间共享，每个进程都有一个唯一的编号。该文件可以被多个进程同时访问，但有如下约束:当前访问该文件的所有进程关联的所有唯一编号之和必须小于n。通过写监视器来协调对该文件的访问。一个文件在不同的进程之间共享，每个进程都有一个唯一的编号。该文件可以被多个进程同时访问，但有如下约束:当前访问该文件的所有进程关联的所有唯一编号之和必须小于n。通过写监视器来协调对该文件的访问。
答：
![在这里插入图片描述](https://img-blog.csdnimg.cn/40c05c6b44bd471988c2ac33cd394f5b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP6b6Z5Yek5Zui6Iy2,size_16,color_FFFFFF,t_70,g_se,x_16)
# 第六章 CUP调度
### 6.1 cpu调度算法决定了被调度进程的执行顺序。给定在一个处理器上调度n个进程，可能有多少种不同的调度?给出一个用n表示的公式。
答：n！种调度
### 6.2 解释抢占式调度和非抢占式调度的区别。
答：抢占式调度允许进程在执行过程中被中断，将CPU取走并分配给另一个进程。非抢占式调度，一旦CPU分配给一个进程，那么这个进程会一直使用CPU知道进程终止，或切换到等待状态。
### 6.3 假设以下进程在指定的时间到达执行。每个进程将按照列出的时间运行。在回答这些问题时，使用非抢占式调度，并根据你所掌握的信息做出所有决策。![在这里插入图片描述](https://img-blog.csdnimg.cn/7bc773bded3d4c4eb23870f22789a70b.png)
a.使用FCFS调度算法，这些流程的平均周转时间是多少?                                          
b.使用SJF调度算法，这些进程的平均周转时间是多少?                                        
c. SJF算法应该是为了提高性能，但是请注意，我们选择在时间0运行进程P1，因为我们不知道两个更短的进程将很快到达。如果第一个单元的CPU处于空闲状态，计算平均周转时间，然后使用SJF调度。请记住，进程P1和P2在这段空闲时间内正在等待，因此它们的等待时间可能会增加。这种算法可以称为未来知识调度。
答：
a. 10.53
b. 9.53
c. 6.86
记住，周转时间是完成时间减去到达时间，所以您必须减去到达时间来计算周转时间。
如果你忘记减去到达时间的话，FCFS是11
### 6.4 在多级排队系统的不同级别上拥有不同的时间片（time quantum）大小有什么好处?
答：需要更频繁服务的进程(例如，编辑器等交互进程)可以在一个时间量较小的队列中。不需要频繁服务的进程可以在一个具有更大量子的队列中，需要更少的上下文切换来完成处理，从而更有效地利用计算机。
### 6.6 假设调度算法(在短期CPU调度级别上)偏爱最近使用了最少处理器时间的那些进程。为什么这个算法更青睐I/ o限制的程序，而不是永久地耗尽cpu限制的程序?
答：它将有利于I/ o限制程序，因为它们的CPU突发请求相对较短;但是，CPU绑定的程序不会饿死，因为I/O绑定的程序会相对频繁地放弃CPU来执行它们的I/O操作。
### 6.10 为什么区分CPU密集型程序和I/O密集型程序对调用程序很重要?
答：I/O密集型程序具有在执行IO之前只执行少量计算的特性。这类程序通常不会使用它们的全部CPU量。另一方面，CPU密集型程序使用它们的整个CPU，而不执行任何IO阻塞操作。因此，通过赋予I/O密集型程序更高的优先级，并允许它们在CPU密集型程序之前执行，可以更好地利用计算机资源。
### 6.11 讨论以下几对调度标准在某些情况下如何冲突。
a. CPU利用率和响应时间 
b.平均周转时间和最小等待时间 
c. I/O设备利用率和CPU利用率
答：CPU利用率和响应时间:如果最小化与上下文切换相关的开销，CPU利用率就会增加。通过不频繁地执行上下文切换，可以降低上下文切换的开销。然而，这可能会增加流程的响应时间。
平均周转时间和最小等待时间:通过先执行最短的任务来最小化平均周转时间。然而，这样的调度策略可能会耗尽长时间运行的任务，从而增加它们的等待时间。
I/O设备利用率和CPU利用率:在不进行上下文切换的情况下，运行长时间与CPU绑定的任务，可以最大化CPU利用率。在I/O密集型程序准备好运行时立即进行调度，可以最大化I/O设备利用率，但会因此增加上下文切换造成的开销。
### 6.14 假设采用指数平均公式来预测下一个CPU执行的长度。当采用如下参数数值时，该算法的含义是：![在这里插入图片描述](https://img-blog.csdnimg.cn/bb3842c3e4fd4011a6479849c24e419e.png)


